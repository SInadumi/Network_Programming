[プログラムの使用法]
1．「ido.o」が存在するディレクトリ内で以下のコマンドを実行する．ポート番号が設定されていない場合，ポート番号は50001が設定される．
　./ido -n [ユーザ名] -p [ポート番号]

2．サーバとして起動した場合，「QUIT」以外の文字を入力したとき，すべてのクライアントに対してメッセージが送信される．
「QUIT」を入力したとき，終了シグナルがすべてのクライアントに送信され，サーバ・全クライアントが終了する．

3．クライアントとして起動した場合，「QUIT」以外の文字を入力したとき，サーバに対してメッセージが送信される．
「QUIT」を入力したとき，サーバに対して終了シグナルが送信され，クライアントは終了する．

[プログラムの特徴]
クライアントの接続とクライアントからのメッセージ受理を独立に処理するため，クライアントが接続されるたびにスレッドを立てた．

[苦労した点]
クライアントの接続・メッセージ受信・抹消など，クライアントの管理部分．

[設計書と異なる点]
・設計書にはクライアント管理の部分があいまいであったため，以下にサーバの流れを改めて記す．
1．引数をもとに，TCP・UDPサーバを立ち上げる．サーバで使用するデータ構造を定義し，TCPサーバへ接続可能な最大のクライアント数の分だけメモリを確保する．
2．Selectを使用し，標準入力・TCPソケット・UDPソケットを監視する． TCPポートへの受信があれば3へ，UDPポートへの受信があれば4へ，キーボード入力があれば7へ移行する． 
3．スレッドを1つ立ち上げる．受信したメッセージが「”JOIN”+ユーザ名」形式ならば，6へ移行する．「”JOIN”+ユーザ名」形式でなければ7へ移行する．クライアントが最大数接続されている場合，接続拒否メッセージを送信する．
4．UDPによる受信メッセージが，”HELO”ならば，”HERE”メッセージを送信し2へ移行する．
5．キーボードからの入力をTCPクライアントに送信する．入力が”QUIT”ならばクライアントへ終了メッセージを送信し，サーバプログラムを終了させる．そうでなければ，2へ移行する．
6．送信したクライアントの名前と既にログイン済みのユーザ一覧を比較する．ユーザ一覧に登録されていれば7へ，登録されていなければ8へ移行する．
7．ユーザ名一覧を参照して，全ユーザにメッセージを「ユーザ名+メッセージ」形式で送信する．クライアントの受信を監視するならば9へ，クライアントの接続を監視するならば2へ移行する．
8．サーバにクライアントのユーザ名とTCPソケットを紐付けて登録し，9へ移行する．
9．スレッド内でSelectを使用し，TCPソケットへの受信を監視する．受信が"QUIT"でなければ7へ，"QUIT"ならば10へ移行する．
10．クライアントの情報を抹消・クライアントへ終了メッセージを送信し，スレッドを終了する．

・子スレッドの動作(9,10)を実現する関数 void *client_thread(void *arg)　を追加した．
・クライアント情報の抹消を行う関数 void del_client(int accept_sock) を追加した．
・文字列から特定の文字列を取り出すときに使用する関数 char *chop_string(char *s, char *chop, int num)を追加した．


